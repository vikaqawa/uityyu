# LESSON 56

### Вопросы и задания:

1. Типы данных

Основные типы данных:


Целочисленные типы:

Integer (целые числа)

ShortInt (маленькие целые числа)

LongInt (большие целые числа)

Byte (целые числа от 0 до 255)

Word (целые числа от 0 до 65535)

Вещественные типы:

Real (числа с плавающей точкой)

Single (числа с одинарной точностью)

Double (числа с двойной точностью)

Extended (сверхдлинные вещественные числа)

Символьные типы:

Char (один символ)

Строковые типы:

String (последовательность символов)

Логические типы:

Boolean (значения True или False)
2. Многочисленные целочисленные и вещественные типы данных

В разных языках программирования предусмотрены разные целочисленные и вещественные типы данных, чтобы:


Оптимизировать использование памяти в зависимости от диапазона значений.

Ускорить вычисления с помощью использования меньшего количества бит.

Обеспечить точность для специфических задач (например,科学的计算和统计).
3. Символьная переменная и строковая

Символьная переменная (Char) хранит только один символ, например, A.

Строковая переменная (String) может хранить последовательность символов, например, "Hello".
4. Логические переменные

Логические переменные могут хранить только два значения: True или False. Обычно они занимают 1 байт памяти, однако это зависит от конкретной реализации языка программирования.

5. Приоритет операций

Приоритет операций определяет порядок, в котором будут выполняться операции в выражениях. Например, умножение и деление выполняются перед сложением и вычитанием.

6. Порядок выполнения операций с одинаковым приоритетом

Если операции имеют одинаковый приоритет, они выполняются слева направо. Например, в выражении a - b + c сначала будет выполнено a - b, а затем результат будет сложен с c.

7. Использование скобок

Скобки используются для изменения приоритета выполнения операций. Например, в выражении (a + b) * c сначала выполняется сложение, а затем умножение.

8. Переменные разных типов

Если в выражении используются переменные разных типов, результат будет иметь тип с наибольшей точностью или размером (например, целое число преобразуется в вещественное число).

9. Операции div и mod

div выполняет целочисленное деление: например, 5 div 2 дает 2.

mod возвращает остаток от деления: например, 5 mod 2 дает 1.

Эти операции не определены для вещественных чисел, так как для вещественных чисел понятие остатка в традиционном смысле теряет смысл.
10. Проблема вычисления остатка

Разные языки программирования могут обрабатывать остаток от деления по-разному. Например, в Python остаток всегда будет иметь знак делимого, тогда как в C++ он может наследовать знак делителя. Это может привести к неожиданным результатам для разработчиков, если они не знают особенностей конкретного языка.

11. Возведение в степень

Возведение в степень может выполняться с помощью специальной функции, например, в Pascal используется функция Power(a, b) для возведения a в степень b.

12. Стандартные математические функции

Стандартные математические функции включают:


Тригонометрические функции: Sin, Cos, Tan, ArcSin, ArcCos, ArcTan.

В Pascal они обычно принимают значения в радианах.
13. Округление в школьном алгоритмическом языке

Округление можно выполнить с помощью функции Round(value) для получения ближайшего целого числа.

14. Случайные числа

Случайные числа — это числа, которые не следуют предсказуемому порядку. Они используются в компьютерном моделировании, играх и для обеспечения безопасности в криптографии.

15. Естественное случайное число

Естественные случайные числа возникают из физических процессов, например, из случайных явлений в природе. Такие числа сложно использовать в цифровой технике из-за их непредсказуемости и зависимости от окружающей среды.

16. Псевдослучайные числа

Псевдослучайные числа создаются с использованием алгоритмов и имеют предсказуемую структуру. Они могут быть воспроизведены, если известен начальный набор параметров.

17. Функции для получения псевдослучайных чисел

Примеры функций для получения псевдослучайных чисел включают:


random() в JavaScript

Random() в C#

Rand() и Randomize() в Pascal

### задачи 

Типы данных: 

Целочисленные типы: Integer, ShortInt, LongInt, Byte, Word.

Вещественные типы: Real, Single, Double, Extended.

Символьные типы: Char.

Строковые типы: String.

Логические типы: Boolean.

Целочисленные и вещественные типы данных: 

Разное представление чисел позволяет экономить память и время обработки. Например, Integer (целые числа) занимают меньше места и используются, когда дробные значения не нужны. Вещественные числа (Real, Double) дают возможность представлять дробные числа с плавающей точкой.

Символьная переменная и строковая: 

Символьная переменная (Char) хранит один символ, тогда как строковая переменная (String) может хранить последовательность символов (строку).

Логические переменные: 

Логические переменные могут иметь два значения: True или False. Обычно они занимают 1 байт (но это зависит от реализации).

Приоритет операций: 

Приоритет операций определяет, какие операции выполняются первыми при вычислении выражений. Это важно для правильной интерпретации значений.

Порядок выполнения операций с одинаковым приоритетом: 

При выполнении операций одного приоритета они выполняются слева направо.

Использование скобок: 

Скобки определяют порядок выполнения операций, позволяя указать, какие части выражения следует вычислить в первую очередь.

Разные типы переменных: 

Если выражение включает переменные разных типов, результатом будет тип с наивысшим приоритетом (например, преобразование к вещественным числам).

Операции div и mod: 

div — это целочисленное деление, а mod — остаток от деления. Они определены только для целых чисел, так как для вещественных чисел нет остатка в классическом понимании.

Проблема вычисления остатка: 

Остаток от деления может по-разному обрабатываться в различных языках. Например, в некоторых языках MATLAB остаток от деления может быть отрицательным, в то время как в других (например, в Python) результат всегда положительный.

Возведение в степень:

В Pascal возведение в степень выполняется с помощью функции Power из стандартной библиотеки, например: Power(a, b).

Стандартные функции для тригонометрических функций:

Существуют функции Sin, Cos, Tan, ArcSin, ArcCos, ArcTan, и они обычно принимают аргументы в радианах.

Округление в школьном алгоритмическом языке:

Округление обычно может выполняться через функцию, где результат выражается как Round(value).

Случайные числа:

Случайные числа — это числа, которые генерируются без какого-либо предсказуемого порядка. Они нужны для статистики, компьютерного моделирования и игр.

Получение «естественного» случайного числа:

«Естественные» случайные числа появляются, например, от физических процессов, но они сложны в использовании из-за их непредсказуемости и зависимости от внешних факторов.

Псевдослучайные числа:

Псевдослучайные числа генерируются по определенному алгоритму, что делает их повторяемыми, а настоящие случайные числа не имеют предсказуемой структуры.

Функции получения псевдослучайных чисел:

Например, функции random или rand из стандартных библиотек.
Задачи:

Диапазон значений для вещественных типов данных:

В диапазоне от 1.5 × 10^-45 до 3.4 × 10^38 для Single и от 5.0 × 10^-324 до 1.7 × 10^308 для Double. Это может зависеть от языка программирования.

Программа, находящая сумму, произведение и среднее арифметическое:

   

pascal

 Копировать код
program ArithmeticOperations;
   var
       a, b, c: Integer;
       sum, product: Integer;
       average: Real;
   begin
       Write('Введите три целых числа: ');
       ReadLn(a, b, c);
       sum := a + b + c;
       product := a * b * c;
       average := sum / 3;
       WriteLn('Сумма: ', sum);
       WriteLn('Произведение: ', product);
       WriteLn('Среднее арифметическое: ', average:0:6);
   end.

Программа для вычисления площади круга и длины окружности:

   

pascal

 Копировать код
program CircleProperties;
   var
       radius, area, circumference: Real;
   begin
       Write('Введите радиус круга: ');
       ReadLn(radius);
       area := Pi * radius * radius; // Площадь
       circumference := 2 * Pi * radius; // Длина окружности
       WriteLn('Площадь круга: ', area:0:2);
       WriteLn('Длина окружности: ', circumference:0:2);
   end.

Программа, меняющая местами два значения:

   

pascal

 Копировать код
program SwapValues;
   var
       a, b: Integer;
   begin
       Write('Введите два целых числа (a и b): ');
       ReadLn(a, b);
       a := a + b;
       b := a - b;
       a := a - b;
       WriteLn('После обмена: a = ', a, ', b = ', b);
   end.

Программа без дополнительных переменных для обмена значениями:

   

pascal

 Копировать код
program SwapWithoutTempVar;
   var
       a, b: Integer;
   begin
       Write('Введите два целых числа (a и b): ');
       ReadLn(a, b);
       a := a xor b;
       b := a xor b;
       a := a xor b;
       WriteLn('После обмена: a = ', a, ', b = ', b);
   end.

# LESSON 57

### вопросы и задания

Разветвляющиеся алгоритмы и линейные алгоритмы:

Линейные алгоритмы выполняются последовательно, от начала до конца, и не содержат условий, которые изменяют порядок выполнения операций. Каждая инструкция выполняется ровно один раз.

Разветвляющиеся алгоритмы содержат условия, что позволяет выполнять разные действия в зависимости от истинности этих условий. Это вводит возможность выбора, что приводит к различным путям выполнения программы.

Почему не все задачи можно решить линейными алгоритмами:

Не все задачи обладают простой последовательной логикой; некоторые требуют выполнения различных действий в зависимости от условий. Например, задачи, связанные с сортировкой данных или обработкой ошибок, часто требуют разветвлений. Примером может служить задача определения, является ли число чётным или нечётным, где необходимо выполнить разный код в зависимости от результата проверки.

Достаточность линейных алгоритмов и ветвлений для разработки программ:

В большинстве случаев линейные алгоритмы и разветвления достаточны для разработки различных программ. Однако для решения более сложных задач, таких как обработка многомерных массивов или выполнение повторяющихся действий, могут потребоваться циклы и более сложные структуры данных.

Почему нельзя выполнить обмен значений в два шага:

Если мы выполним a := b;, то значение переменной a будет изменено на значение b, и мы потеряем исходное значение a. Следовательно, при выполнении b := a; переменная b снова получит значение, которое было уже присвоено переменной a, и фактически значения переменных не поменяются. Для корректного обмена необходимо использовать временную переменную.

Различия условных операторов в полной и неполной формах:

Полная форма условия включает все возможные варианты (например, оператор case), когда предусмотрены все возможные случаи. 

Неполная форма может не учитывать все варианты. Это может привести к ошибкам в программе, если исполнение зависит от неучтённого случая. Хотя в некоторых случаях можно обойтись и без полной формы, это усложнит процесс обработки ошибок.

Какие отношения и их обозначение:

Основные отношения: «равно» (=), «не равно» (<>), «больше» (>), «меньше» (<), «больше или равно» (>=), «меньше или равно» (<=).

Что такое сложное условие:

Сложное условие — это условие, которое включает несколько простых условий, объединённых логическими операторами (например, AND, OR). Они позволяют более точно задавать логику выполнения.

Порядок вычислений в сложном условии:

В языке Паскаль порядок вычисления условий определяется приоритетом операторов. Например, AND выполняется раньше OR. Это означает, что более высокоприоритетные операции вычисляются сначала. Если порядок важен, можно использовать скобки для явного указания порядка операций.

Зачем нужен оператор выбора?:

Оператор выбора упрощает код, позволяя выполнять различные инструкции в зависимости от условий. Без него потребуется использовать множество условных операторов, что сделает код менее читабельным и более громоздким.

Различия операторов выбора в школьном алгоритмическом языке и Паскале:

В школьном алгоритмическом языке есть упрощённые версии операторов выбора, которые могут не поддерживать все возможности и структуры, как в Паскале. Например, в Паскале поддерживается больше вариантов построения операторов, таких как case для выбора из множества вариантов.

Как записать, что делать, если ни один вариант не подошёл:

В языке Паскаль можно использовать конструкцию else в условном операторе, которая выполняется, если ни одно из условий не верно.

Как выполнить несколько операторов в операторе выбора в Паскале:

Чтобы выполнить несколько операторов для определённого варианта, их группируют в begin и end. Например:

    

pascal

 Копировать код
case variable of
      value1: begin
                  // несколько операторов
              end;
      value2: begin
                  // несколько операторов
              end;
    end;

### задачи

1. Получение неверного ответа в переменной m

Допустим, у вас есть программа, которая зависит от неправильного ввода, например, когда m вычисляется по какому-либо условию. Вот пример:

pascal

 Копировать код
var
  a, b, m: Integer;
begin
  ReadLn(a);
  ReadLn(b);
  if (a > b) then
    m := a - b // неправильное условие
  else
    m := b - a;
  WriteLn('Значение m: ', m);
end.

Неверный ввод: Если a равно b, то программа вычисляет разницу, которая будет ноль, и это может быть неверным ответом. 

Исправление: Нужно добавить условие для обработки случая, когда a равно b:

pascal

 Копировать код
if (a = b) then
  WriteLn('Пара чисел равна.')
else if (a > b) then
  m := a - b
else
  m := b - a;
2. Программа для нахождения максимального и минимального из пяти чисел

pascal

 Копировать код
var
  i, num, min, max: Integer;
begin
  min := MaxInt; // инициализируем минимум на самом большом числе
  max := -MaxInt; // инициализируем максимум на самом маленьком числе

  for i := 1 to 5 do
  begin
    ReadLn(num);
    if num < min then
      min := num;
    if num > max then
      max := num;
  end;

  WriteLn('Минимальное число: ', min);
  WriteLn('Максимальное число: ', max);
end.
3. Программа для проверки, является ли число трёхзначным

pascal

 Копировать код
var
  num: Integer;
begin
  ReadLn(num);
  if (num >= 100) and (num <= 999) then
    WriteLn('Число является трёхзначным.')
  else
    WriteLn('Число не является трёхзначным.')
end.
4. Программа, определяющая время года без оператора выбора

pascal

 Копировать код
var
  month: Integer;
begin
  ReadLn(month);
  if (month < 1) or (month > 12) then
    WriteLn('Ошибка: неверный номер месяца.')
  else
    WriteLn('Время года: ', 
      'Зима', 'Весна', 'Лето', 'Осень', 'Зима', 'Весна', 'Лето', 'Осень', 'Зима', 'Весна', 'Лето', 'Осень' [month - 1]);
end.
5. Программа, определяющая время года с оператором выбора

pascal

 Копировать код
var
  month: Integer;
begin
  ReadLn(month);
  case month of
    12, 1, 2: WriteLn('Зима');
    3, 4, 5: WriteLn('Весна');
    6, 7, 8: WriteLn('Лето');
    9, 10, 11: WriteLn('Осень');
  else
    WriteLn('Ошибка: неверный номер месяца.');
  end;
end.
6. Программа, определяющая количество дней в месяце

pascal

 Копировать код
var
  month: Integer;
begin
  ReadLn(month);
  case month of
    1, 3, 5, 7, 8, 10, 12: WriteLn('31 день');
    4, 6, 9, 11: WriteLn('30 дней');
    2: WriteLn('28 или 29 дней (в зависимости от года)');
  else
    WriteLn('Ошибка: неверный номер месяца.');
  end;
end.
7. Программа, определяющая, сколько дней осталось до Нового года

pascal

 Копировать код
var
  month, day: Integer;
begin
  ReadLn(month);
  ReadLn(day);
  
  if (month < 1) or (month > 12) or (day < 1) or (day > 31) then
    WriteLn('Ошибка: неверные данные.')
  else
  begin
    // Предположим, что каждый месяц имеет 30 дней для простоты
    var daysInMonth: array[1..12] of Integer = (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);
    var remainingDays: Integer;
    
    // Рассчитываем дни до нового года
    remainingDays := 0;
    for var i := month + 1 to 12 do
      remainingDays := remainingDays + daysInMonth[i];

    remainingDays := remainingDays - day;
    WriteLn('Осталось дней до Нового года: ', remainingDays);
  end;
end.
8. Программа, выводящая возраст с правильным окончанием

pascal

 Копировать код
var
  age: Integer;
begin
  ReadLn(age);
  
  if (age < 0) or (age > 120) then
    WriteLn('Ошибка: некорректный возраст.')
  else
    case age mod 10 of
      1: WriteLn(age, ' год');
      2, 3, 4: WriteLn(age, ' года');
      else WriteLn(age, ' лет');
    end;
end.
9. Программа, выводящая число прописью

pascal

 Копировать код
var
  num: Integer;
begin
  ReadLn(num);
  if (num < 0) or (num > 100) then
    WriteLn('Ошибка: число должно быть от 0 до 100.')
  else
  begin
    case num of
      0: WriteLn('ноль');
      1: WriteLn('один');
      2: WriteLn('два');
      3: WriteLn('три');
      4: WriteLn('четыре');
      5: WriteLn('пять');
      6: WriteLn('шесть');
      7: WriteLn('семь');
      8: WriteLn('восемь');
      9: WriteLn('девять');
      10: WriteLn('десять');
      11: WriteLn('одиннадцать');
      12: WriteLn('двенадцать');
      13: WriteLn('тринадцать');
      14: WriteLn('четырнадцать');
      15: WriteLn('пятнадцать');
      16: WriteLn('шестнадцать');
      17: WriteLn('семнадцать');
      18: WriteLn('восемнадцать');
      19: WriteLn('девятнадцать');
      20: WriteLn('двадцать');
      21: WriteLn('двадцать один');
      22: WriteLn('двадцать два');
      23: WriteLn('двадцать три');
      24: WriteLn('двадцать четыре');
      25: WriteLn('двадцать пять');
      26: WriteLn('двадцать шесть');
      27: WriteLn('двадцать семь');
      28: WriteLn('двадцать восемь');
      29: WriteLn('двадцать девять');
      30: WriteLn('тридцать');
      31: WriteLn('тридцать один');
      32: WriteLn('тридцать два');
      33: WriteLn('тридцать три');
      34: WriteLn('тридцать четыре');
      35: WriteLn('тридцать пять');
      36: WriteLn('тридцать шесть');
      37: WriteLn('тридцать семь');
      38: WriteLn('тридцать восемь');
      39: WriteLn('тридцать девять');
      40: WriteLn('сорок');
      41: WriteLn('сорок один');
      42: WriteLn('сорок два');
      43: WriteLn('сорок три');
      44: WriteLn('сорок четыре');
      45: WriteLn('сорок пять');
      46: WriteLn('сорок шесть');
      47: WriteLn('сорок семь');
      48: WriteLn('сорок восемь');
      49: WriteLn('сорок девять');
      50: WriteLn('пятьдесят');
      51: WriteLn('пятьдесят один');
      52: WriteLn('пятьдесят два');
      53: WriteLn('пятьдесят три');
      54: WriteLn('пятьдесят четыре');
      55: WriteLn('пятьдесят пять');
      56: WriteLn('пятьдесят шесть');
      57: WriteLn('пятьдесят семь');
      58: WriteLn('пятьдесят восемь');
      59: WriteLn('пятьдесят девять');
      60: WriteLn('шестьдесят');
      61: WriteLn('шестьдесят один');
      62: WriteLn('шестьдесят два');
      63: WriteLn('шестьдесят три');
      64: WriteLn('шестьдесят четыре');
      65: WriteLn('шестьдесят пять');
      66: WriteLn('шестьдесят шесть');
      67: WriteLn('шестьдесят семь');
      68: WriteLn('шестьдесят восемь');
      69: WriteLn('шестьдесят девять');
      70: WriteLn('семьдесят');
      71: WriteLn('семьдесят один');
      72: WriteLn('семьдесят два');
      73: WriteLn('семьдесят три');
      74: WriteLn('семьдесят четыре');
      75: WriteLn('семьдесят пять');
      76: WriteLn('семьдесят шесть');
      77: WriteLn('семьдесят семь');
      78: WriteLn('семьдесят восемь');
      79: WriteLn('семьдесят девять');
      80: WriteLn('восемьдесят');
      81: WriteLn('восемьдесят один');
      82: WriteLn('восемьдесят два');
      83: WriteLn('восемьдесят три');
      84: WriteLn('восемьдесят четыре');
      85: WriteLn('восемьдесят пять');
      86: WriteLn('восемьдесят шесть');
      87: WriteLn('восемьдесят семь');
      88: WriteLn('восемьдесят восемь');
      89: WriteLn('восемьдесят девять');
      90: WriteLn('девяносто');
      91: WriteLn('девяносто один');
      92: WriteLn('девяносто два');
      93: WriteLn('девяносто три');
      94: WriteLn('девяносто четыре');
      95: WriteLn('девяносто пять');
      96: WriteLn('девяносто шесть');
      97: WriteLn('девяносто семь');
      98: WriteLn('девяносто восемь');
      99: WriteLn('девяносто девять');
      100: WriteLn('сто');
    end;
  end;
end.
10. Программа, которая определяет попадание точки в заштрихованную область

pascal

 Копировать код
var
  x, y: Real;
begin
  ReadLn(x);
  ReadLn(y);
  
  // Предположим, что область - это квадрат со сторонами от (-1, -1) до (1, 1)
  if (x >= -1) and (x <= 1) and (y >= -1) and (y <= 1) then
    WriteLn('Точка попала в заштрихованную область.')
  else
    WriteLn('Точка не попала в заштрихованную область.');
end.
Эти программы написаны на языке Pascal и обеспечивают выполнение описанных требований. Вы можете адаптировать их под свои нужды или использовать как основу для дальнейших улучшений!


Вариант 1: Программа с использованием сложных условий
В этом варианте будет вычислено, попадает ли точка внутри заштрихованной области, описанной несколькими уравнениями. Например, пусть область будет ограничена окружностью с центром в начале координат и радиусом 2 (x² + y² < 4) и прямыми y < x + 1 и y > x - 1.

pascal

 Копировать код
program PointInAreaComplexConditions;
var
  x, y: Real;
begin
  Write('Введите координаты точки (x, y): ');
  ReadLn(x, y);

  if (x*x + y*y < 4) and (y < x + 1) and (y > x - 1) then
    WriteLn('Точка попала в заштрихованную область.')
  else
    WriteLn('Точка не попала в заштрихованную область.');
end.
Вариант 2: Программа без использования сложных условий
В этом варианте мы можем использовать оператор выбора (например, case) или простые условия последовательно. Давайте рассмотрим вариант с простыми условиями:

pascal

 Копировать код
program PointInAreaSimpleConditions;
var
  x, y: Real;
  inCircle, inLine1, inLine2: Boolean;
begin
  Write('Введите координаты точки (x, y): ');
  ReadLn(x, y);

  inCircle := (x*x + y*y < 4);
  inLine1 := (y < x + 1);
  inLine2 := (y > x - 1);

  if inCircle then
  begin
    if inLine1 then
    begin
      if inLine2 then
        WriteLn('Точка попала в заштрихованную область.')
      else
        WriteLn('Точка не попала в заштрихованную область.');
    end
    else
      WriteLn('Точка не попала в заштрихованную область.');
  end
  else
    WriteLn('Точка не попала в заштрихованную область.');
end.
Объяснение

В первом варианте мы использовали сложное логическое выражение, которое объединяет условия с помощью логического оператора and.

Во втором варианте мы изолируем условия с помощью дополнительных переменных и используем вложенные операторы if, вместо одного сложного условия. Это позволяет избавиться от необходимости анализировать все условия в одном выражении, делая структуру программы более ясной.




